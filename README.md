# Библиотека деревьев поиска

## Описание проекта

Учебный проект по реализации различных типов деревьев поиска на языке C++. Проект демонстрирует три подхода к организации бинарных деревьев поиска с разными стратегиями балансировки.

## Структура проекта

```
├── CMakeLists.txt                # Конфигурация сборки CMake
├── headers/                      # Заголовочные файлы
│   ├── ITree.h                   # Интерфейс всех деревьев
│   ├── BSTree.h                  # Простое бинарное дерево поиска
│   ├── AVLTree.h                 # Сбалансированное AVL-дерево
│   ├── Treap.h                   # Декартово дерево (Treap)
│   ├── OptimalBST.h              # Оптимальное дерево поиска
│   ├── RandomizeBST.h            # Рандомизированное дерево
│   ├── Splay.h                   # Расширяющееся дерево
│   ├── OptimalTreap.h            # Оптимальное Декартово дерево
│   └── TreeTest.h                # Шаблонный класс для тестирования
├── src/
│   └── main.cpp                  # Основная программа тестирования
└── report/
    ├── output.txt, output_2_.txt # Полные результаты тестирования    
    └── report.md, report_2.md    # Подробный отчёт с анализом производительности    

```

## Реализованные структуры данных

### 1. **BSTree** (Binary Search Tree)
Простое бинарное дерево поиска без балансировки.
- **Особенности:** Классическая реализация, все методы итеративные
- **Сложность:** O(h) в худшем случае, где h может достигать O(n)
- **Применение:** Учебный пример, демонстрация проблем вырожденных деревьев

### 2. **AVLTree** (AVL Tree)
Сбалансированное дерево поиска с поддержанием инварианта высоты.
- **Особенности:** Автоматическая балансировка через вращения
- **Сложность:** O(log n) гарантированно в худшем случае
- **Преимущества:** Стабильная производительность, предсказуемое поведение

### 3. **Treap** (Декартово дерево)
Рандомизированное дерево поиска, сочетающее свойства BST и кучи.
- **Особенности:** Балансировка через случайные приоритеты, операции split/merge
- **Сложность:** O(log n) в среднем случае
- **Преимущества:** Проще в реализации чем AVL, хорошая производительность

## Расширенные структуры данных (часть 2)

### 4. **OptimalBST** (Оптимальное бинарное дерево поиска)
Статическое дерево, построенное с использованием динамического программирования.
- **Особенности:** Минимальная средневзвешенная глубина поиска, квадратичные требования к памяти
- **Сложность:** O(n²) времени и памяти на построение, O(log n) на поиск
- **Применение:** Статические словари, базы данных с фиксированными данными

### 5. **RandomizedBST** (Рандомизированное BST)
Бинарное дерево поиска с вероятностной балансировкой.
- **Особенности:** Четыре стратегии рандомизации (FIXED, INVERSE_N, INVERSE_SQRT_N, INVERSE_LOG_N)
- **Сложность:** O(log n) в среднем случае на случайных данных
- **Преимущества:** Хороший компромисс между простотой и эффективностью

### 6. **SplayTree** (Дерево со сплей-операциями)
Самонастраивающееся дерево, перемещающее часто используемые элементы к корню.
- **Особенности:** Сплай-операции (zig, zig-zig, zag-zag), адаптация к паттернам доступа
- **Сложность:** O(log n) амортизированное время, O(n) в худшем случае
- **Применение:** Кэширование, системы с локальностью запросов

### 7. **OptimalTreap** (Оптимизированное декартово дерево)
Гибридная структура, сочетающая Treap и сплей-операции.
- **Особенности:** Частичные сплей-операции при поиске, гарантии балансировки
- **Сложность:** O(log n) в среднем случае, улучшенная локальность
- **Преимущества:** Стабильность Treap с адаптивностью SplayTree


## Особенности реализации

- **Общий интерфейс:** Все деревья реализуют интерфейс `ITree<T>`
- **Типобезопасность:** Использование шаблонов C++ с концептами C++20
- **Итеративные методы:** Избегание переполнения стека при вырожденных деревьях
- **Поддержка семантики перемещения:** Эффективное управление памятью
- **Полный набор операций:** Вставка (кроме Optimal BST), удаление (кроме Optimal BST), поиск, обходы (inorder, preorder, postorder, level-order)

## Требования к сборке

- **Компилятор:** Поддерживающий C++20 (GCC 10+, Clang 10+, MSVC 2019+)
- **Система сборки:** CMake 3.16+
- **Тестирование:** Google Test (опционально)

## Сборка проекта

```bash
mkdir build && cd build
cmake ..
cmake --build .
```


## Тестирование

Проект включает комплексный тестовый фреймворк `TreeTest`, который позволяет:
- Проверять корректность операций
- Измерять производительность
- Сравнивать разные реализации деревьев
- Тестировать граничные случаи

Подробные результаты тестирования и анализ производительности приведены в [report.md](report/report.md) и [report_2.md](report/report_2.md).
