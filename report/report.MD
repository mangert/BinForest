# Отчёт по реализации и тестированию деревьев поиска

## Общая информация

В рамках проекта реализованы три типа деревьев поиска с общим интерфейсом `ITree<T>`:
- **BSTree** - простое бинарное дерево поиска (несбалансированное)
- **AVLTree** - сбалансированное AVL-дерево
- **Treap** - декартово дерево (рандомизированное)

**Общие особенности:**
- Не поддерживают дубликаты ключей
- Все операции поиска работают за O(h), где h - высота дерева
- Реализуют полный набор операций: вставка, удаление, поиск, обходы


## Реализации деревьев

### [BSTree](./headers/BSTree.h) - простое бинарное дерево поиска

**Особенности реализации:**
- Классическая реализация BST без балансировки
- Все основные методы реализованы итеративно для избежания переполнения стека при вырожденных деревьях
- В худшем случае (отсортированные данные) вырождается в связный список
- Сложность операций: O(h), где h может достигать O(n)

### [AVLTree](./headers/AVLTree.h) - сбалансированное AVL-дерево

**Особенности реализации:**
- Автоматическая балансировка после каждой операции вставки/удаления
- Балансировка через вращения (малые и большие)
- Поддержание инварианта: |баланс-фактор| ≤ 1
- Гарантированная высота: h ≤ 1.44·log₂(n+2)-1
- Сложность операций: O(log n) в худшем случае

### [Treap](./headers/Treap.h) - декартово дерево

**Особенности реализации:**
- Комбинация бинарного дерева поиска и кучи по приоритетам
- Балансировка достигается за счёт случайных приоритетов
- Основные операции через split и merge
- Ожидаемая высота: O(log n) с высокой вероятностью
- Не требует явной балансировки
- Поддерживает только типы с определёнными операциями для удаления (int, long, std::string)

## Тестирование производительности

### Методика тестирования

Для каждого дерева выполнены тесты с:
1. **N=1,000,000** элементов для всех трёх типов деревьев
2. **N=10,000,000** элементов только для AVLTree и Treap (BSTree не тестировался из-за чрезмерного времени выполнения)

Для каждого размера тестировались два сценария:
- **Отсортированные данные** (наихудший случай для BST)
- **Случайные данные** (типичный случай)

Измерялось время:
- Построения дерева
- Поиска 10% случайных элементов
- Удаления 10% случайных элементов

### Результаты тестирования

Для тестирования использовался шаблонный класс [TreeTest](./headers/TreeTest.h)

[Просмотреть полный вывод тестирования](output.txt)

### Результаты тестирования (N=1,000,000)

#### BSTree
| Операция | Отсортированные данные | Случайные данные |
|----------|------------------------|------------------|
| **Построение** | 3,336,562 ms (≈55 мин) | 625 ms |
| **Высота** | 999,999 (вырождено) | 52 |
| **Поиск 10%** | 392,161 ms (≈6.5 мин) | 64 ms |
| **Удаление 10%** | 2,486,831 ms (≈41 мин) | 225 ms |

#### AVLTree
| Операция | Отсортированные данные | Случайные данные |
|----------|------------------------|------------------|
| **Построение** | 302 ms | 999 ms |
| **Высота** | 19 | 23 |
| **Поиск 10%** | 15 ms | 61 ms |
| **Удаление 10%** | 38 ms | 117 ms |

#### Treap
| Операция | Отсортированные данные | Случайные данные |
|----------|------------------------|------------------|
| **Построение** | 334 ms | 1,764 ms |
| **Высота** | 52 | 51 |
| **Поиск 10%** | 15 ms | 97 ms |
| **Удаление 10%** | 83 ms | 204 ms |

### Результаты тестирования (N=10,000,000)

#### AVLTree
| Операция | Отсортированные данные | Случайные данные |
|----------|------------------------|------------------|
| **Построение** | 3,351 ms | 16,126 ms |
| **Высота** | 23 | 27 |
| **Поиск 10%** | 158 ms | 1,094 ms |
| **Удаление 10%** | 426 ms | 1,811 ms |

#### Treap
| Операция | Отсортированные данные | Случайные данные |
|----------|------------------------|------------------|
| **Построение** | 4,012 ms | 28,984 ms |
| **Высота** | 58 | 62 |
| **Поиск 10%** | 166 ms | 1,828 ms |
| **Удаление 10%** | 917 ms | 3,112 ms |

## Сводная таблица производительности (N=1,000,000)

| Тип дерева | Сценарий | Построение (ms) | Высота | Поиск 10% (ms) | Удаление 10% (ms) | Время на операцию (μs) |
|------------|----------|-----------------|--------|----------------|-------------------|------------------------|
| **BSTree** | Отсортир. | 3,336,562 | 999,999 | 392,161 | 2,486,831 | 3,921 / 24,868 |
| **BSTree** | Случайные | 625 | 52 | 64 | 225 | 0.64 / 2.25 |
| **AVLTree** | Отсортир. | 302 | 19 | 15 | 38 | 0.15 / 0.38 |
| **AVLTree** | Случайные | 999 | 23 | 61 | 117 | 0.61 / 1.17 |
| **Treap** | Отсортир. | 334 | 52 | 15 | 83 | 0.15 / 0.83 |
| **Treap** | Случайные | 1,764 | 51 | 97 | 204 | 0.97 / 2.04 |

## Выводы

1. **BSTree катастрофически деградирует на отсортированных данных:**
   - Вырождается в связный список (высота ≈ n)
   - Время операций растёт квадратично
   - Непригоден для реального использования с упорядоченными данными

2. **AVLTree демонстрирует стабильную производительность:**
   - Гарантирует логарифмическую высоту (19-27 при 10M элементов)
   - Быстрее всех на отсортированных данных
   - Немного уступает Treap на случайных данных при поиске
   - Самый предсказуемый по производительности

3. **Treap показывает хорошую производительность:**
   - Приемлемая высота (51-62 при 1M-10M элементов)
   - Быстрый поиск на отсортированных данных
   - Проще в реализации чем AVL (не нужны вращения)
   - Занимает больше памяти (хранит приоритеты)

4. **Сравнительные характеристики:**

   | Критерий | BSTree | AVLTree | Treap |
   |----------|--------|---------|-------|
   | Гарантия высоты | O(n) | **O(log n)** | O(log n) (в среднем) |
   | Скорость вставки (отсорт.) | O(n) | **O(log n)** | O(log n) |
   | Скорость поиска (отсорт.) | O(n) | **O(log n)** | O(log n) |
   | Скорость удаления (отсорт.) | O(n) | **O(log n)** | O(log n) |
   | Память на узел | **3 поля** | 4 поля | 4 поля |
   | Сложность реализации | низкая | высокая | средняя |

5. **Рекомендации по выбору:**
   - **AVLTree** - когда нужны гарантии производительности и предсказуемость
   - **Treap** - когда важна простота реализации и данные преимущественно случайные
   - **BSTree** - только для учебных целей или при гарантированно случайных данных

**Итоговый вердикт:** Для реальных приложений сбалансированные деревья (AVL или Treap) необходимы. AVLTree показал себя как наиболее сбалансированное решение по всем параметрам, обеспечивая стабильную производительность независимо от характера входных данных.