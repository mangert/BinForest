# Отчёт по реализации и тестированию расширенных структур данных

## Общая информация

В рамках проекта реализованы расширенные структуры данных на основе деревьев поиска:
- **OptimalBST** - оптимальное статическое бинарное дерево поиска (динамическое программирование)
- **RandomizedBST** - рандомизированное бинарное дерево поиска с различными стратегиями вероятностей
- **SplayTree** - дерево со сплей-операциями (самонастраивающаяся структура)
- **OptimalTreap** - декартово дерево с оптимизированными операциями поиска и сплея
- **Treap** (из предыдущего ДЗ) - классическое декартово дерево для сравнения

**Общие особенности:**
- Не поддерживают дубликаты ключей
- Реализуют интерфейс ITree<T>
- Все структуры корректно обрабатывают граничные случаи

## Реализации структур

### [OptimalBST](../headers/OptimalBST.h) - оптимальное статическое БДП

**Особенности реализации:**
- Построение с использованием динамического программирования за O(n²) времени и O(n²) памяти
- Оптимальная структура для статических данных при известных вероятностях доступа
- Не поддерживает динамические операции вставки/удаления
- Шаблонный параметр MAX_SIZE для контроля использования памяти

### [RandomizedBST](../headers/RandomizedBST.h) - рандомизированное БДП

**Особенности реализации:**
- Четыре стратегии рандомизации балансировки:
  - **FIXED** (фиксированная вероятность 10%)
  - **INVERSE_LOG_N** (вероятность ∝ 1/log n)
  - **INVERSE_N** (вероятность ∝ 1/n)
  - **INVERSE_SQRT_N** (вероятность ∝ 1/√n)
- Итеративная реализация для избежания переполнения стека
- Балансировка происходит во время операций вставки
- Сохраняет свойства BST для отсортированных обходов

### [SplayTree](../headers/SplayTree.h) - дерево со сплей-операциями

**Особенности реализации:**
- Итеративная реализация сплей-операции (zig, zig-zig, zag-zag)
- Не требует хранения родительских указателей
- Автоматически перемещает часто используемые элементы ближе к корню
- Отдельные неконстантный метод поиска find_and_update() для поиска с обновлением
- Сожранен константный метод contains() для проверки без модификации

### [OptimalTreap](../headers/OptimalTreap.h) - оптимизированное декартово дерево

**Особенности реализации:**
- Комбинация Treap и сплей-операций
- Частичный сплей при поиске для улучшения локальности данных
- Полный сплей выполняется только при достижении триггерного условия
- Сохранение баланса через случайные приоритеты
- Оптимизированные операции для последовательных доступов

## Тестирование производительности

### Методика тестирования

Для каждой структуры выполнены тесты с размерами:
1. **N=10,000** элементов для всех структур (кроме OBST для больших N)
2. **N=100,000** элементов (OBST исключён из-за ограничений памяти)
3. **N=1,000,000** элементов (только для наиболее производительных структур)

Для каждого размера тестировались два сценария:
- **Отсортированные данные** (проверка устойчивости к вырождению)
- **Случайные данные** (типичный случай использования)

Измеряемые параметры:
- Время построения
- Высота дерева
- Время поиска 10% случайных элементов
- Время удаления 10% случайных элементов (где применимо)

### Результаты тестирования

Для тестирования использовался шаблонный класс [TreeTest](../headers/TreeTest.h)

[Просмотреть полный вывод тестирования](output_2.txt)


#### Для N=10,000 элементов

| Структура | Стратегия | Построение (отсорт.) | Высота (отсорт.) | Поиск 10% (отсорт.) | Построение (случ.) | Высота (случ.) | Поиск 10% (случ.) |
|-----------|-----------|----------------------|------------------|---------------------|---------------------|----------------|-------------------|
| **OptimalBST** | - | 7,537 ms | 16 | 0 ms | 7,153 ms | 16 | 0 ms |
| **RandomizedBST** | FIXED | 1 ms | 1,890 | 6 ms | 2 ms | 32 | 0 ms |
| **RandomizedBST** | INVERSE_LOG_N | 1 ms | 1,728 | 5 ms | 2 ms | 31 | 0 ms |
| **RandomizedBST** | INVERSE_N | 76 ms | 6,185 | 7 ms | 2 ms | 31 | 0 ms |
| **RandomizedBST** | INVERSE_SQRT_N | 2 ms | 384 | 0 ms | 2 ms | 30 | 0 ms |
| **SplayTree** | - | 2 ms | 9,999 | 24 ms | 4 ms | 40 | 0 ms |
| **Treap** | - | 2 ms | 30 | 0 ms | 7 ms | 30 | 0 ms |
| **OptimalTreap** | - | 3 ms | 32 | 0 ms | 9 ms | 30 | 0 ms |

#### Для N=100,000 элементов

| Структура | Стратегия | Построение (отсорт.) | Высота (отсорт.) | Поиск 10% (отсорт.) | Построение (случ.) | Высота (случ.) | Поиск 10% (случ.) |
|-----------|-----------|----------------------|------------------|---------------------|---------------------|----------------|-------------------|
| **RandomizedBST** | FIXED | 13 ms | 18,938 | 1,168 ms | 46 ms | 40 | 5 ms |
| **RandomizedBST** | INVERSE_LOG_N | 16 ms | 12,723 | 700 ms | 43 ms | 43 | 3 ms |
| **RandomizedBST** | INVERSE_N | 6,243 ms | 24,600 | 523 ms | 30 ms | 42 | 3 ms |
| **RandomizedBST** | INVERSE_SQRT_N | 61 ms | 1,210 | 31 ms | 35 ms | 47 | 3 ms |
| **SplayTree** | - | 23 ms | 99,999 | 2,394 ms | 61 ms | 62 | 4 ms |
| **Treap** | - | 33 ms | 39 | 1 ms | 102 ms | 42 | 4 ms |
| **OptimalTreap** | - | 30 ms | 38 | 1 ms | 110 ms | 36 | 4 ms |

#### Для N=1,000,000 элементов

| Структура | Стратегия | Построение (отсорт.) | Высота (отсорт.) | Поиск 10% (отсорт.) | Построение (случ.) | Высота (случ.) | Поиск 10% (случ.) |
|-----------|-----------|----------------------|------------------|---------------------|---------------------|----------------|-------------------|
| **RandomizedBST** | INVERSE_LOG_N | 164 ms | 105,562 | 165,610 ms | 896 ms | 52 | 94 ms |
| **RandomizedBST** | INVERSE_N | 1,373,837 ms | 316,770 | 131,741 ms | 644 ms | 50 | 64 ms |
| **RandomizedBST** | INVERSE_SQRT_N | 1,921 ms | 4,107 | 1,984 ms | 719 ms | 50 | 74 ms |
| **SplayTree** | - | 231 ms | 999,999 | 521,186 ms | 1,240 ms | 82 | 117 ms |
| **Treap** | - | 315 ms | 46 | 15 ms | 1,911 ms | 49 | 107 ms |
| **OptimalTreap** | - | 375 ms | 51 | 20 ms | 2,014 ms | 46 | 109 ms |

## Сводная таблица производительности

### Лучшие результаты по категориям (N=100,000):

| Категория | Победитель | Время построения | Высота | Время поиска | Комментарий |
|-----------|------------|------------------|--------|--------------|-------------|
| **Лучшая балансировка** | Treap/OptimalTreap | 30-110 ms | 36-42 | 1-4 ms | Идеальная высота O(log n) |
| **Лучшее время построения** | RandomizedBST (INVERSE_SQRT_N) | 35-61 ms | 1,210-47 | 3-31 ms | Хороший компромисс |
| **Лучшая устойчивость к отсортированным данным** | OptimalBST | 7,153-7,537 ms | 16 | 0 ms | Оптимальная статическая структура |
| **Лучшая адаптивность** | SplayTree | 23-61 ms | 62-99,999 | 4-2,394 ms | Улучшается после повторных поисков |

## Анализ стратегий RandomizedBST

### Сравнение стратегий (N=100,000, отсортированные данные):

| Стратегия | Время построения | Высота | Время поиска 10% | Эффективность |
|-----------|------------------|--------|------------------|---------------|
| **FIXED (10%)** | 13 ms | 18,938 | 1,168 ms | Средняя, стабильная |
| **INVERSE_LOG_N** | 16 ms | 12,723 | 700 ms | Хорошая, предсказуемая |
| **INVERSE_N** | 6,243 ms | 24,600 | 523 ms | Медленное построение |
| **INVERSE_SQRT_N** | 61 ms | 1,210 | 31 ms | **Наилучший баланс** |

**Вывод:** Стратегия INVERSE_SQRT_N (1/√n) показала наилучший компромисс между временем построения и качеством балансировки.

## Сравнительный анализ структур

### 1. **OptimalBST**
- **Плюсы:** Идеальная структура для статических данных, минимальная средняя глубина поиска
- **Минусы:** Квадратичная сложность по памяти и времени построения, не поддерживает динамические операции
- **Применение:** Базы данных с фиксированным набором записей, словари

### 2. **RandomizedBST**
- **Плюсы:** Простая реализация, хорошая балансировка на случайных данных, различные стратегии адаптации
- **Минусы:** Может вырождаться на отсортированных данных (особенно при редкой балансировке)
- **Применение:** Системы с преимущественно случайными запросами

### 3. **SplayTree**
- **Плюсы:** Отличная локальность, адаптация к паттернам доступа, быстрые повторные поиски
- **Минусы:** Худший случай O(n) для одиночных поисков, не гарантирует сбалансированность
- **Применение:** Кэширование, системы с неравномерным распределением запросов

### 4. **OptimalTreap**
- **Плюсы:** Гарантированная логарифмическая высота в среднем, адаптивность к запросам
- **Минусы:** Сложность реализации, дополнительные накладные расходы
- **Применение:** Универсальные структуры данных, требующие баланса производительности

## Ключевые выводы

1. **Для статических данных оптимальным выбором является OptimalBST**, но его применение ограничено из-за квадратичных требований к памяти.

2. **RandomizedBST с стратегией INVERSE_SQRT_N** показала наилучший баланс между простотой реализации и производительностью, особенно на больших наборах данных.

3. **SplayTree демонстрирует уникальное свойство адаптивности**: время поиска значительно улучшается при повторных запросах к тем же элементам.

4. **Treap и OptimalTreap** обеспечивают наиболее стабильную и предсказуемую производительность независимо от характера входных данных.

5. **На отсортированных данных все динамические структуры (кроме Treap) подвержены вырождению**, что подтверждает важность балансировки.

6. **Оптимальный выбор структуры зависит от специфики приложения**:
   - Для работы с фиксированными данными: **OptimalBST**
   - Для общего назначения со случайными данными: **RandomizedBST (INVERSE_SQRT_N)**
   - Для множественных повторяющихся запросов: **SplayTree**
   - Для гарантированной производительности: **Treap/OptimalTreap**


**Итоговый вывод:** Разнообразие реализованных структур демонстрирует различные подходы к решению проблемы балансировки деревьев поиска. Каждая структура имеет свою нишу применения, и оптимальный выбор зависит от конкретных требований приложения к производительности, памяти и характеру операций.